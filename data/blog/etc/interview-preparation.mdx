---
title: '기술 면접 준비'
date: '2024-01-11'
tags: ['interview']
draft: true
summary: 기술 면접 준비를 해보자.
---

## 알고리즘

### DP(Dynamic programming)

복잡한 문제를 간단한 여러 개의 하위 문제로 나누어 푸는 방법이다.
하위 단계의 최적해를 저장하여 다음 최적해를 구할 때 재사용하면 효율을 증가시킬 수 있다.
이를 memoization이라고 한다.

동일한 하위 문제로 이루어진 복잡한 문제에서 사용한다.

피보나치의 경우 f(n-1) + f(n-2)의 값을 저장하여 계산한 문제를 다시 계산하지 않도록 할 수 있다.

### Greedy(탐욕법)

현재 가장 좋은 방법만 선택하는 알고리즘이다.
시간은 빠르지만 최적해를 구하지 못하는 경우가 있다.

값이 작은 동전으로 값이 큰 동전을 만들 수 있는 기본적인 동전 문제가 예시가 될 수 있다.

### 분할정복(Divide and conquar)

복잡한 문제를 복잡하지 않은 문제로 쪼개어 정복하고 병합하는 방법이다.

합병정렬이 예시이다.

## 정렬

### 버블정렬

인접한 두개의 값을 비교하는 방법이다.
시간 복잡도는 O(n^2)이다

### 선택정렬

오름차순의 경우 가장 작은 값을 찾아 뒤로 보내는 방법이다.
가장 큰 값을 찾을 때마다 리스트의 크기가 작아진다.
시간 복잡도는 O(n^2)이다

### 삽입정렬

현재 값과 앞의 값들을 비교하여 알맞은 위치에 배치하는 방법이다.
앞의 값들이 정렬되어 있을 수록 시간 복잡도가 떨어진다.

시간 복잡도는 O(n^2)이다

### 합병정렬

배열을 반으로 분할해가면서 더 이상 분할되지 않을때 부터 결합하는 방법이다.

시간 복잡도는 O(nlogn)이다

### 힙정렬

최대힙이나 최소힙을 사용하여 정렬하는 방법이다.

원소들을 최소힙으로 만들고 마지막 노드와 루트 노드를 교환하면서 나열한다.

시간 복잡도는 O(nlogn)이다

### 퀵정렬

분할 정복을 사용하여 pivot을 기준으로 큰 것과 작은 것을 나누는 방법이다.

시간 복잡도는 O(nlogn)이지만 pivot이 가장 큰 값이나 가장 작은 값이 되는 경우 O(n^2)이 된다.
이런 문제를 예방하기 위해 적절한 pivot을 정하는 것이 좋다.

## 소수 찾기

2부터 √N까지 나눠보는 방식과 에라토스테네스 체를 사용하는 방법이 있다.
에라토스테네스 체는 소수를 찾으면 그 소수의 배수를 제거하는 것이다.

시간 복잡도는 O(nloglogn)이다.

## 자료구조

### Array

논리적 저장 순서와 물리적 저장 순서가 같다.
원소에 인덱스를 알고 있을때 접근하는데 O(1)의 시간복잡도를 갖는다.

하지만 값을 추가하거나 삭제할때 원소들이 이동해야하기 때문에 최악의 경우 O(n)이 된다.

### Linked list

각 원소가 다음 원소의 위치를 기억하고 있는 자료구조이다.
논리적 저장 순서와 물리적 저장 순서가 다르다.

값을 추가하거나 삭제할때 O(1)이지만 값의 위치를 찾아야 하기 때문에 O(n)이 된다.

### Stack과 Queue

스택은 Last In First Out으로 나중에 들어간 원소가 먼저 나온다.

Stack은 함수 콜 스택과 브라우저 네비게이션 스택에 사용된다.

큐는 First In First Out으로 먼저 들어간 원소가 먼저 나온다.

### Tree

Tree는 비선형 구조로 계층적 관계를 표현하는 자료구조이다.
노드와 간선으로 이루어져 있다.

### Binary Tree

노드의 하위 노드가 두개까지만 존재하는 트리이다.
이진 트리의 서브 트리 또한 이진 트리가 되어야 하며 공집합과 노드가 한개뿐인 것도 이진 트리가 될 수 있다.

Perfect Binary Tree : 모든 레벨이 꽉찬 이진 트리
Complete Binary Tree : 왼쪽에서 오른쪽으로 값이 순서대로 쌓인 이진 트리
Full Binaray Tree : 모든 노드가 0개 혹은 2개의 자식 노드만 갖는 이진 트리

### BST(Binary Search Tree)

이진탐색트리는 효율적인 탐색을 위해 데이터를 저장하는 규칙을 정한것이다.
부모키가 왼쪽 자식 노드의 키보다 크고 오른쪽 자식 노드의 키보다 작다.
이진 탐색 트리의 탐색 연산은 O(log n)이 되지만 편향트리가 되면 최악의 경우 O(n)이 된다.

트리가 편향되는 문제를 해결하기 위해 리벨런싱이 필요하다.

### Binary Heap

배열에 기반한 완전 이진 트리이다. 노드의 고유번호와 배열의 인덱스가 같다.
루트 노드가 가장 큰 최대힙과 가장 작은 최소 힙 두가지 종류가 있다.

루트 노드가 제거되었을 때는 마지막 노드를 맨 위로 올리고 값에 맞는 자리를 찾아간다.

### Red Black Tree

BST를 기반으로 하는 트리 형식의 자료구조이다. Search, Insert, Delete에 O(log n)의 시간 복잡도가 소요된다.
depth를 최소화하기 위해 완전이진트리 구조이다.
